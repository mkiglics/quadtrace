#version 450
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

restrict writeonly uniform image2D frameData;

uniform int max_iter = 150;
const float MAX_DISTANCE = 10000;
const float EPSILON = 0.001;

uniform sampler3D eccentricity;
uniform sampler3D sdf_values;
uniform ivec3 N;

uniform float delta = 0.8;

uniform vec3 lightPos = vec3(50, 50, 50);

uniform int showQuadric = 0;
uniform ivec3 showcaseQuadricCoord = ivec3(0);


float tanfov = tan(radians(45)/2);
uniform vec3 eye, at, up;
uniform vec2 windowSize;

uniform int error_test = 0;

TraceResult trace(in Ray r, in SphereTraceDesc params);
vec2 quadricGetIntersectionParamters(Ray cameraRay, ivec3 quadricCoord);
vec3 quadricCalculateNormal(vec3 point, ivec3 quadricCoord);

vec3 getNormal(vec3 p, vec3 dim) 
{
    return normalize(vec3(
        SDF(vec3(p.x + EPSILON, p.y, p.z)) - SDF(vec3(p.x - EPSILON, p.y, p.z)),
        SDF(vec3(p.x, p.y + EPSILON, p.z)) - SDF(vec3(p.x, p.y - EPSILON, p.z)),
        SDF(vec3(p.x, p.y, p.z  + EPSILON)) - SDF(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

vec3 gradient(in ivec3 coords)
{
	return texelFetch(eccentricity, coords, 0).yzw;
//	float[8] vert;
//	float[6] c;
//	for (int x = 0; x < 2; ++x)
//	{
//		for (int y = 0; y < 2; ++y)
//		{
//			for (int z = 0; z < 2; ++z)
//			{
//				vert[x*4+y*2+z]=texelFetch(sdf_values, coords+ivec3(x,y,z), 0).r;
//			}
//		}
//	}
//	c[0] = (vert[0] + vert[1] + vert[2] + vert[3]);
//	c[1] = (vert[4] + vert[5] + vert[6] + vert[7]);
//	c[2] = (vert[0] + vert[1] + vert[4] + vert[5]);
//	c[3] = (vert[6] + vert[7] + vert[2] + vert[3]);
//	c[4] = (vert[0] + vert[4] + vert[2] + vert[6]);
//	c[5] = (vert[5] + vert[1] + vert[7] + vert[3]);
//
//
//	vec3 norm = vec3(c[0] - c[1], c[2] - c[3], c[4] - c[5]);
//	return length(norm) > EPSILON ? normalize(norm) : vec3(0, 1, 0);
}


vec3 lighting(in vec3 p)
{
	vec3 ambient = vec3(0.1, 0.1, 0.1);
	vec3 n = getNormal(p,N);
	vec3 toLight = -normalize(p - lightPos);
	vec3 diffuse = vec3(0.6, 0.6, 0.6) * clamp(dot(n, toLight), 0, 1);
	vec3 lightDir = p-lightPos;
	vec3 ref = normalize(reflect(lightDir, n));
	vec3 e = normalize(eye - p);
	vec3 specular = vec3(pow(clamp(dot(ref,e), 0, 1), 32));

	return ambient + diffuse + specular;
}

vec3 quadricLighting(in vec3 p) 
{
	vec3 lightPos = vec3(0, 150, 0);
	vec3 ambient = vec3(0.5, 0.0, 0.0);
	vec3 n = quadricCalculateNormal(p, showcaseQuadricCoord);
	vec3 toLight = -normalize(p - lightPos);
	vec3 diffuse = vec3(0.6, 0.3, 0.3) * clamp(dot(n, toLight), 0, 1);
	vec3 lightDir = p-lightPos;
	vec3 ref = normalize(reflect(lightDir, n));
	vec3 e = normalize(eye - p);
	vec3 specular = vec3(pow(clamp(dot(ref,e), 0, 1), 32));

	// return normalize(n);
	return ambient + diffuse + specular;
}

Ray Camera(vec2 pix, vec3 eye, vec3 at, vec2 dim)
{    
	vec3 w = normalize(at-eye);
    vec3 u = normalize(cross(w,vec3(0,1,0)));
	vec3 v = cross(u,w);
    
    vec2 px = (pix*2.-1.)*1.*normalize(dim);
    
    return Ray(eye,							//P
               0.1,							//minT
               normalize(w+px.x*u+px.y*v),	//V
               MAX_DISTANCE);				//maxT
}

vec3 getQuadricColor(Ray cameraRay, ivec3 quadricPos, vec3 quadricDir, float k) 
{
	mat3 rot = getRotation(quadricDir);
	vec2 tValues = intersectQuadricBoth(rot * (cameraRay.P - quadricPos), rot * cameraRay.V, k);
	bool quadricIntersected = (tValues.x > 0 && !isinf(tValues.x)) || (tValues.y > 0 && !isinf(tValues.y));

	if (quadricIntersected) 
	{
		return quadricLighting(cameraRay.P + cameraRay.V * min(tValues.x, tValues.y));
	}
	else
	{
		return vec3(0);
	}
}

void main()
{
	ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
	Ray r = Camera(coords.xy / windowSize, eye, at, windowSize);

	TraceResult res = trace(r, SphereTraceDesc(EPSILON, max_iter));

	// get intersection parameter with quadric
	vec4 quadricColor = vec4(0);
	vec2 quadricT12 = showQuadric == 0 ? vec2(-1) : quadricGetIntersectionParamters(r, showcaseQuadricCoord);
	bool quadricIntersected = (quadricT12.x > 0 && !isinf(quadricT12.x)) || (quadricT12.y > 0 && !isinf(quadricT12.y));
	float minQuadricT = min(quadricT12.x, quadricT12.y);
	float maxQuadricT = max(quadricT12.x, quadricT12.y);

	// mix color for quadric
	if (quadricIntersected) 
	{
		quadricColor = vec4(quadricLighting(r.P + r.V * minQuadricT), 1);
	}

	if (error_test == 1)
	{
		if (bool(res.flags & 1)) {imageStore(frameData, coords, vec4(1, 0, 0, 1)); return;}
		imageStore(frameData, coords, vec4(res.T/r.Tmax, 0, 0, 1));
		return;
	}
	if (bool(res.flags & 1))		{imageStore(frameData, coords, vec4(0, 0, 0, 1) + quadricColor); return;}
	if (bool(res.flags & 4))		{imageStore(frameData, coords, vec4(1, 0, 0, 1)); return;}
	vec3 p = eye + r.V * res.T;

	vec3 color;
	if (quadricIntersected) 
	{
		const vec3 inFrontOfQuadric = vec3(255, 0, 0) / 255.0;
		const vec3 insideQuadric = vec3(0, 255, 0) / 255.0;
		const vec3 behindQuadric = vec3(0, 0, 255) / 255.0;

		color = (res.T < minQuadricT) ? inFrontOfQuadric :
				(res.T < maxQuadricT) ? insideQuadric    : behindQuadric;
		imageStore(frameData, coords, vec4(color, 1));
		return;
	} 
	else
	{
		color = lighting(p);
	}
	imageStore(frameData, coords, vec4(color, 1) + quadricColor);
}
